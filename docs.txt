type Block struct 
    -> What is it ?
        -> Represents a single unit of storage
        -> This basically defines the structure that a particular block will have
        -> The block holds the following 3 things:
            1. Previous block hash 
            2. Data 
            3. Current block's hash

type Block struct 
    -> A container that holds an ordered sequence of blocks
    -> Uses a Golang slice ([]*Block) to keep the blocks in order

Cryptographic Hashing (How?)
    
    func (b* Block) DeriveHash()
        -> Logic: 
            -> This method combines the block's unique Data and the previous hash into a single byte 
               slice using bytes.Join. It then feeds this combined data into the SHA-256 algorithm (sha256.sum256)
            
            -> This creates immutability of the blockchain. If you change the data in block 1 it's hash changes. Because 
               block 2 stores block 1's hash as prevHash the block 2's hash also changes. This ripple effect alerts the network
               to data tampering

Chain Management:
The code implements the specific functions to manage the lifecycle of the chain
    -> Genesis():
        -> A blockchain being a chain of blocks the first block has nothing to point to with respect to the previous blocks. This function 
        basically hardcodes the block data with Genesis and an empty byte slice for the previous hash. It bootstraps the system.
    
    -> CreateBlock and AddBlock functions:
        -> AddBlock looks at the current end of the chain (chain.blocks[len-1]) to get the latest hash 
        -> It passes this hash and the new data to createBlock
        -> CreateBlock function builds the struct of the new block by getting the data and the previous hash as the arguments and then calling the 
        DeriveHash() function to generate the hash of current block
        -> This function returns a block and then appends it to the current list/array/chain of blocks

Execution Flow
    -> When the main() runs:
        -> InitBlockChain() is called:
            -> It runs the Genesis() function creating the first block
            -> It then returns a blockchain that currently contains the first block 
            
        -> You start to populate the data by calling the AddBlock function
            -> Block 1 is created from the hash of the genesis 
            -> then block 2 from block 1 
            -> then block 3 from block 1 
        
        -> You loop through the chain and print the previous hash, data, and the current hash

------------ 2nd Phase ----------------

-> Implementation of proof of work: 
    -> In the first phase adding the block was instant and really just needed the DeriveHash() function
    but if it is this easy to add a block then any attacker could do it. 
    -> This is why ProofOfWork is implemented which involved solving a difficult math puzzle to add a block
    which makes a block expensive in terms of CPU power and time which in turn secures the network

-> Block and blockchain structs are moved to block.go
-> PoW logic lives in proof.go
-> main.go purely acts as just an entry point

-> Core ProofOfWork Logic
    -> Goal: Find a hash for the block that starts with a specific number of zeros
    -> Constraint: You cannot change the block's data or the previous hash
    -> Varaible: We introduce a new field called Nonce (Number used ONCE)
    
    -> target.Lsh(target, unit(256-difficult))
        -> This uses a left shift operation. Imagine a target number that looks like this in binary: 00001000... 
        Any hash we generate must be smaller than this number. The smaller the target, the harder it is to find a 
        matching hash (because you need more leading zeros).

-> Mining Loop ('The Work'):
    -> Flow: 
        -> Prepare data: Combine prevHash + Data + Nonce + difficult
        -> Generate a SHA-256 hash of that combined data
        -> Compare: Convert the hash to a bigInt
            -> hash < target ? Success we found the golden Nonce stop the loop : Failure increment the nonce by 1 and start from step 1
    -> Why is this important: 
        -> this loop is mining -> it might run millions of times before finding the right hash

-> Validate (): 
    -> Why: 
        -> Mining takes a long time but verification should be instant
    -> How: 
        -> Once the miner finds the nonce anyone can take that nonce, run the hash once and see if it meets the target
            -> This prepares the blockchain for a decentralized network where the nodes need to quickly trust the blocks sent by others wihtout
            remining them
        
-> Final flow after 2nd phase: 
    AddBlock("Data") in main.go -> Creates a block with data and the previous hash -> (Mining) NewProof(block) calculates the target based on difficulty ->
    pow.Run() starts the loop -> It starts trying from Nonce 0 -> Hash Fail -> Tries with Nonce 1 -> Hash Fail ..... -> Eg: Nonce 1245 -> Hash starts with 0000 -> 
    Success! -> The block is saved with that specific Nonce and the resulting hash -> Output terminal shows PoW : true

-> Why is this crucial for the project ? 
    -> Without this the blockchain is just a fancy linked list
    -> With this is becomes a secure digital ledger
    -> The work that is required to change the hash makes the blockcain immutable
    -> If the hacker wants to change the 'Work' for block1 then he has to change the work for block2 and block3 and so on....which is computationally impossible
    
----------PHASE 3---------------
-------------- Addition of Badger DB ------------------
The code introduces persistance using a database (BadgerDB). When you close the program the blocks are now saved to the harddrive
when you open it again, it remebers history

Serialization:
    -> Serialize() and Deserialize()
        -> Serialize: takes the Block struct and flattens it into a byte array
        -> Deserialize: takes the byte array from DB and inflates it back into a readable block
DB integration:
    -> Key - blcok's hash 
    -> value - serialized block data
    -> we use a special key "lh" to store the hash of the newest block

-> Flow:
    Startup(InitBlockChain) -> checks database -> if empty creates genesis and saves it while setting lh to the genesis hash -> 
    if exists -> read "lh" to find the tip of the chain
    Add a Block (AddBlock) -> grabs stored hash in lh -> mines new block pointing to the hash -> saves the new block -> updates the "lh"

---------------------------Entire Flow ------------------------------------
User Input: You type go run main.go add -block "New Transaction". -> Validation: The CLI checks if you used the right commands.
-> Initialization: InitBlockChain opens the folder ./tmp/blocks. It finds the "lh" key to see where we left off.
Processing: -> The system creates a new block. -> Proof of Work (from Part 2) runs to find the nonce. -> The block is Serialized into bytes.
-> The bytes are saved to BadgerDB.
Persistence: The program updates "lh" and closes. The data is now safe on the disk.

------------- PHASE 4 ----------------
---------------------------------------------------------------------------
ADDING TRANSACTIONS

-> The code removes the Data field and replaces it with Transactions. This introduces UTXO(unspent transaction output)
which is the same logic that BTC uses

TxOutput : represents the "Value". It has a Value and PubKey field
TxInput : represents "Spending". It references a previous output ID and provides a Sig to unlock it

CoinBaseTx: This is the first transaction in the block. It has no inputs as it mines for the money

----------Finding the money in the blockchain ----------------
-> To send money you must find where is it hiding in the BC
-> FindUnspentTransactions:
    -> iterates backward through the blockchain using the iterator
    -> looks for the TxOutput that are logged with your name
    -> It checks if the output has already been referenced by a TxInput in a newer block. If it has it is spent, else it is unspent

-> FindSpendableOutput:
    -> It calls the function above and keeps adding up the values until it reaches that amount that you want to spend
    -> It returns the specific IDs of the transactions that you need to 'break' to pay for your transfer

CREATING A TRANSACTION
    -> On running the command send -from John -to Alice -amount 10 the following process happens: 
        -> Check Balance: IT calls the FindSpendableOutput. If the accumulated amount < spending amount it panics (returns error)
        -> Create Inputs: It creates inputs referencing the 'money piles'
        -> Create Outputs: Pays Alice, Pays John back the remainder

---------------FLOW----------------
-> run the command: go run main.go send -from John to Alice -amount 50
-> The code scans the DB. It finds John has the Genesis reward of 100 coins that are unspent
-> It refers to the Genesis Transaction ID (value 100)
-> 50 coins to Alice
-> 50 coins back to John
-> This new transaction is wrapped in a block. The proof of work algo mines this block 
-> The block is saved to badgerDB
-> John's 100 coin is considered output and 2 new 50 coin outputs are created. 

-----------PHASE 5------------
-----------ADDING A WALLET MODULE-------------
Implementation flow -> Refactoring -> The wallet -> Addresses -> Persistance -> CLI

1) Move the CLI into its own package
2) Ensure TXOutput and TxInput structures are in their own files

Wallet in cyrpto holds a private key and public key 

wallet.go -> contains the wallet struct and the function to generate the keys. 


